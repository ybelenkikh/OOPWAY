<!doctype html>
<html lang="en" style="font-size: calc(0.645vh + 0.45em);">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">

</head>
<body style="font-family: sans-serif">
<h2>PHP OOP Way Sergey Zhuk</br>
    This book is for sale at <a href="http://leanpub.com/phpoopway">http://leanpub.com/phpoopway</a></br>
    This version was published on 2019-06-21</br>
    © 2017 - 2019 Sergey Zhuk</h2>
<p>Почему абстракция так важна и какую ценность она приносит для нашего приложения?</p>
<p>Почему мы должны инкапсулировать свойства в классы вместо того, чтобы делать все свойства публичными?</p>
<p>Почему иногда уместно использовать интерфейс, а иногда абстрактный класс.</p>
<p>Почему создание иерархии наследования для повторного использования кода - плохая идея.</p>
<p>Почему лучше передать требуемый объект в качестве аргумента метода, а не создавать его внутри?</p>
<hr>
<h1>Fundamentals</h1>
<div class="bundlePropertiesWithMethods">
    <h2>Связывание свойств с методами</h2>
    <h4>Инкапсуляция</h4>
    <div class="parent">
        <div class="Class">
            <p>class User</p>
            <p>{</p>
            <p class="p-l">private $name;</p>
            <p class="p-l">private $email;</p>
            <p class="p-l pb-1">private $age;</p>
            <p class="p-l">public function __construct(string $name, string $email, int $age)</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->name = $name;</br> $this->email = $email;</br> $this->setAge($age);</p>
            <p class="p-l">}</p>
            <p class="p-l">public function getAge():int</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return $this->age;</p>
            <p class="p-l">}</p>
            <p class="p-l">public function setAge(int $age):self</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return $this->age = abs($age);</p>
            <p class="p-l">}</p>
            <p class="p-l">public function isYoung():bool</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return $this->age < 18;</p>
            <p class="p-l">}</p>

            <p>}</p>
        </div>
        <div class="description">
            <p>Основная идея инкапсуляции - связать данные с методами.</p>
            <p>Основная цель - ограничить возможности неправильного использования нашего класса.</p>
            <p>Считайте инкапсуляцию сокрытием деталей объекта от внешнего мира и
                предоставление общедоступного интерфейса для взаимодействия с этим
                объектом</p>
            <p>Инкапсуляция - это метод, используемый как часть абстракции. Инкапсуляция касается состояния объектов
                когда они скрывают это от внешнего мира. Пользователи класса могут взаимодействовать с ним с помощью его методов, но
                не может напрямую получить доступ к своему состоянию.</p>
        </div>
    </div>
</div>
<hr>
<div class="defineANewType">
    <h2>Определение нового типа данных</h2>
    <h4>Абстракция</h4>
    <div class="parent">
        <div class="">
            <p class="pb-1">Новый абстрактный класс определяет интерфейс для этого нового типа данных. Когда мы предоставляем общедоступные методы
                мы говорим: «Эй, с переменной этого типа данных вы можете сделать это, и она будет вести себя в этом
                определенный способ". Это очень важно, когда мы рассматриваем класс как тип данных. Его публичный интерфейс
                - это набор правил, определяющих способ взаимодействия с этим типом.</p>
            <div class="abstractClass">
                <p>abstract class AbstractClass</p>
                <p>{</p>
                <p>// нельзя создать объекты абстрактного класса</p>
                <p>// в дочернем классе необходимо определить все абстрактные методы обязательно</p>
                <p class="">}</p>
            </div>

        </div>
        <div class="description">
            <p>Абстракция - «это что-то о повторном использовании кода»</p>
            <p>Есть много разных способов добиться повторного использования кода, и наихудший из них - абстракция.</p>
            <p>Абстракция - это удаление ненужных деталей, чтобы описать что-то более простым языком.
                термины, чтобы сосредоточиться только на важных аспектах текущего контекста.</p>
        </div>
    </div>
</div>
<hr>
<div class="familiesOfRelatedTypes">
    <h2>Семейства родственных типов</h2>
    <h4>Наследование</h4>
    <div class="parent">
        <div class="Class">
            <p>class Task</p>
            <p>{</p>
            <p class="p-l">private $isClosed;</p>
            <p class="p-l pb-1">private $closedAt;</p>
            <p class="p-l">public function close()</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->isClosed = true;</p>
            <p class="p-l-1">$this->closedAt = date("Y-d-m H:i:s");</p>
            <p class="p-l-1">return $this;</p>
            <p class="p-l">}</p>
            <p class="pb-1">}</p>
            <p>class Project extends Task</p>
            <p>{</p>
            <p class="p-l">public function close</p>
            <p class="p-l">{</p>
            <p class="p-l-1">parent::close();</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <div class="Class">
                <p>class User</p>
                <p>{</p>
                <p class="p-l">public function completeTask(Project $project)</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$task->close();</p>
                <p class="p-l">}</p>
                <p>}</p>
                <p>$user->completeTask(new Project());</p>
            </div>
        </div>
    </div>
</div>
<hr>
<div class="differentTypesWithTheSameBehavior">
    <h2>Различные типы данных с одинаковым поведением</h2>
    <h4>Интерфейс</h4>
    <div class="parent">
        <div class="Class">
            <div class="interface">
                <p>interface Flyable</p>
                <p>{</p>
                <p class="p-l">public function fly(int $distance);</p>
                <p class="pb-1">}</p>
            </div>
            <p>final class Bird implements Flyable</p>
            <p>{</p>
            <p class="p-l">public function fly(int $distance)</p>
            <p class="p-l">{</p>
            <p class="p-l">}</p>
            <p class="pb-1">}</p>
            <div class="abstractClass">
                <p>abstract class FlyableEntity</p>
                <p>{</p>
                <p class="p-l pb-1">protected $wings;</p>
                <p class="p-l">abstract public function fly(int $distance);</p>
                <p>}</p>
            </div>
        </div>
        <div class="description">
            <p>Интерфейс - это гарантия между программистом и его кодом</p>
            <p>Различие интерфейсов с классами заключается во множественном наследовании, которое доступно для интерфейсов</p>
            <div class="interface">
                <p>interface LoggerInterface extends WritableInterface, ReadableInterface</p>
                <p>{</p>
                <p>}</p>
            </div>
            <hr>
            <p>Абстрактный класс также предоставляет интерфейс. Отличие, что абстрактный класс может предоставить
                логику реализации для своих методов</p>
            <p>final class Bird extends FlyableEntity</p>
            <p>{</p>
            <p class="p-l">public function fly(int $distance)</p>
            <p class="p-l">{</p>
            <p></p>
            <p class="p-l">}</p>
            <p>}</p>
            <p>Эта иерархия предназначена только для того, чтобы продемонстрировать разницу между интерфейс и абстрактный класс.</p>
        </div>
    </div>
</div>
<hr>
<div class="InterfaceVsAbstractClass">
    <h2>Интерфейс. Абстрактный класс.</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
            <div class="abstractClass">
                <p>abstract class Cache</p>
                <p>{</p>
                <p class="p-l">abstract public function get(Cacheable $entity);</p>
                <p class="p-l">abstract public function set(Cacheable $entity);</p>
                <p class="pb-1">}</p>
            </div>
            <div class="interface">
                <p>interface Cacheable</p>
                <p>{</p>
                <p class="p-l">public function getCacheKey();</p>
                <p class="p-l">public function getCacheData();</p>
                <p class="pb-1">}</p>
            </div>
            <p>class Category implements Cacheable</p>
            <p>{</p>
            <p class="p-l">public function getCacheKey(): string</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return 'product_' . $this->id;</p>
            <p class="p-l">}</p>
            <p class="p-l">public function getCacheData(): array</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return [];</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
           <p>При использовании абстрактных классов наши константы могут иметь значения переменных</p>
            <div class="interface">
                <p>interface MathInterface</p>
                <p>{</p>
                <p>const PI = 3.14159;</p>
                <p>}</p>
            </div>
            <p>С помощью абстрактного класса мы определяем новый тип данных, который имеет собственный
                интерфейс.</p>
            <p>Интерфейс предоставляет только публичное объявление методов. Гарантия на код клиента
                который взаимодействует с объектами, реализующими этот интерфейс.</p>
        </div>
    </div>
</div>
<hr>
<div class="traits">
    <h2>Трейты</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
          <div class="error">
              <p>class Product</p>
              <p>{</p>
              <p class="p-l">private $name;</p>
              <p class="p-l">public function slug(): string</p>
              <p class="p-l">{</p>
              <p class="p-l-1">$cleared = preg_replace( '/[^A-Za-z0-9-]+/', '-', $this->name );</p>
              <p class="p-l-1">return strtolower($cleared);</p>
              <p class="p-l pb-1">}</p>
              <p>class Category</p>
              <p>{</p>
              <p class="p-l">private $name;</p>
              <p class="p-l">public function slug(): string</p>
              <p class="p-l">{</p>
              <p class="p-l-1">$cleared = preg_replace( '/[^A-Za-z0-9-]+/', '-', $this->name );</p>
              <p class="p-l-1">return strtolower($cleared);</p>
              <p class="p-l">}</p>
              <p>}</p>
              <p class="pb-1">// дублирование кода</p>
          </div>
          <div class="Class">
                <p>class Category implements Sluggable</p>
                <p>{</p>
                <p class="p-l">use HasSlug;</p>
                <p class="p-l pb-1">private $name;</p>
                <p class="p-l ">protected function getStringForSlug(): string</p>
                <p class="p-l">{</p>
                <p class="p-l-1">return $this->name;</p>
                <p class="p-l">}</p>
                <p class="p-l">public function parent(): self</p>
                <p class="p-l">{</p>
                <p class="p-l">}</p>
                <p class="p-l">public function products(): array</p>
                <p class="p-l">{</p>
                <p class="p-l">}</p>
                <p class="pb-1">}</p>
                <p>class Product implements Sluggable</p>
                <p>{</p>
                <p class="p-l">use HasSlug;</p>
                <p class="p-l">private $name;</p>
                <p class="p-l">private $shortName;</p>
                <p class="p-l">protected function getStringForSlug(): string</p>
                <p class="p-l">{</p>
                <p class="p-l-1">return $this->shortName;</p>
                <p class="p-l">}</p>
                <p>}</p>
            </div>
        </div>
        <div class="description">
            <p>Трейты - это механизм повторного использования кода в языках с единичным наследованием, таких как PHP</p>
            <p>Трейты позволяют нам извлекать тесно связанную группу методов в единый многоразовый
                item. А потом этот item можно вставлять в классы.</p>
            <p>Трейты - очень мощный и гибкий инструмент в языках без множественного наследования.
                Они могут улучшить кодовую базу и убрать дублирование из классов. Но с другой стороны,
                они могут усложнить или даже сломать приложение при неосторожном использовании.</p>
            <div class="Trait">
                <p>trait HasSlug</p>
                <p>{</p>
                <p>public function slug(): string</p>
                <p>{</p>
                <p>$string = $this->getStringForSlug();</p>
                <p>
                    if (!property_exists($this, 'name')) {
                    throw new Exception(
                    'No property "name" to create slug'
                    );</p>
                <p>$cleared = preg_replace(
                    '/[^A-Za-z0-9-]+/', '-', $string
                    );</p>
                <p>return strtolower($cleared);</p>
                <p>}</p>
                <p>abstract protected function getStringForSlug(): string;</p>
                <p>}</p>
            </div>
            <div class="interface">
                <p>interface Sluggable</p>
                <p>{</p>
                <p>public function slug(): string;</p>
                <p>}</p>
                <p>Класс который хочет использовать трейт HasSlug должен реализовывать интерфейс Sluggable.</p>
            </div>
        </div>
    </div>
</div>
<div class="polymorphism">
    <h2>Полиморфизм</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
                <p>final class Application</p>
                <p>{</p>
                <p class="p-l">private $cache;</p>
                <p class="p-l">public function setCache(Cache $cache): void</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->cache = $cache;</p>
                <p class="p-l">}</p>
                <p class="p-l">public function flushCache()</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->cache->flush();</p>
                <p class="p-l">}</p>
                <p>}</p>
                <div class="abstractClass">
                    <p>abstract class Cache</p>
                    <p>{</p>
                    <p class="p-l">abstract public function flush(): void;</p>
                    <p>}</p>
                </div>
                <p>final class MemcacheCache extends Cache</p>
                <p>{</p>
                <p class="p-l">public function flush(): void</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->memcache->flush();</p>
                <p class="p-l">}</p>
                <p>}</p>
            <p>final class RedisCache extends Cache</p>
            <p>{</p>
            <p class="p-l">public function flush(): void</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->redis->flush();</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <p>Subtype Polymorphism</p>
            <p>В терминах ООП это означает, что когда у нас есть методы в разных классах,
                которые делают похожие вещи, мы должны дать этим методам одно и то же имя.</p>
            <p> За одним именем мы спрятали разную логику, поэтому можем смело добавлять новые
                реализации, и каждый класс, который знает это имя, автоматически знает, как сотрудничать
                с новыми реализациями.</p>
        </div>
    </div>
</div>

<h1>50</h1>

<!--
<h2>35-249</h2>
<h1>Bundle Properties With Methods</h1>
<h3>Инкапсуляция</h3>
<h3>
    1* Основная идея инкапсуляции - связать данные с методами.
</h3>
<h3>
    2* Основная цель - ограничить возможности неправильного использования нашего класса.
</h3>
<p>// есть private свойство<sup>2*</sup>, в котором хранится возраст пользователя и некоторые методы, которые работают с этими данными<sup>1*</sup></p>
<p>Считайте инкапсуляцию сокрытием деталей объекта от внешнего мира и
    предоставление общедоступного интерфейса для взаимодействия с этим
    объектом.
</p>
<h3>Определение нового типа</h3>
<h3>Новый тип данных new User()</h3>
<p>$user = new User('John', 'john@example.com', 18);</p>
<h3>Итого</h3>
<p>
    Абстракция - это удаление ненужных деталей, чтобы описать что-то более простым языком, чтобы сосредотачиваться только на
    важных аспектах  текущего контекста.
</p>
<p>
    Инкапсуляция - это метод, используемый как часть абстракции. Инкапсуляция касается состояния объектов когда они скрывают это от внешнего мира. Пользователи класса могут взаимодействовать с ним с помощью его методов, но не могут напрямую получить доступ к своему состоянию. Абстракция - это более  общий термин, он часто не возможен без инкапсуляция.
</p>
<h3>Семейства родственных типов</h3>
<h3>Наследование</h3>
<h3>Разные типы с одинаковым поведением</h3>
<h3>Интерфейс</h3>
<p>interface InterfaceName</p>
<p>{</p>
<p>public function method($parameter);</p>
<p>}</p>
<p>один интерфейс может быть унаследован от другого с помощью ключевого слова extends</p>
<p>interface ChildInterface extends ParentInterface</p>
<p>Одно из отличий от классов заключается в множественном наследовании, которое доступно для интерфейсов:</p>
<p>interface LoggerInterface extends WritableInterface, ReadableInterface</p>
<p> Когда нам нужно гарантировать, что объект реализует некоторые методы, мы можем использовать интерфейс. Интерфейс - это гарантия между программистом и его кодом</p>
<h3>Интерфейс и абстрактный класс</h3>
<h3>Полиморфизм</h3>
<h3>Предоставление единого интерфейса для разных типов</h3>
<p>Полиморфизм здесь - это комбинация реализации интерфейса (абстрактного класса или интерфейса) в ваших классах</p>

<h3>SOLID</h3>
<h3>S - single responsibility</h3>
<h5>ПРИНЦИП ЕДИНСТВЕННОЙ ОТВЕТСТВЕННОСТИ</h5>
<p>Цель - создать небольшие полезные классы, которые должны нести единственную ответственность</p>


<p>class Category</p>
<p>{</p>
<p>public function addProduct(Product $product): self</p>
<p>{</p>
<p>if (auth()->user() instanceof Admin) {</p>
<p>throw new UnAuthorizedException;</p>
<p>//add product to the category</p>
<p>return $this;</p>
<p>}</p>
<p>}</p>
<p>// Здесь 2 обязанности: добавление новых товаров в категорию и проверка подлинности пользователя </p>
<p>// Которые следует переместить или извлечь из класса</p>

<p>final class OrderPaymentService</p>
<p>{</p>
<p>private $order;</p>
<p>private $paymentGateway;</p>
<p>public function __construct(PaymentGateway $paymentGateway)</p>
<p>{</p>
<p>$this->order = $order;</p>
<p>$this->paymentGateway = $paymentGateway;</p>
<p>}</p>
<p>public function pay(Order $order) {</p>
<p>$this->paymentGateway->charge(</p>
<p>$this->order->getId(),</p>
<p>$this->order->getTotal(),</p>
<p>$this->order->getCustomerId()</p>
<p>);</p>
<p>}</p>
<p>}</p>
<hr>
<h3>O -open-close</h3>
<h4>Принцип открытости закрытости </h4>
<h5>Классы должны быть открыты для расширения, но закрыты для модификации.</h5>
<h4>Смысл принципа - Конструкция системы должна быть проста и устойчива к изменениям</h4>
<h2>1</h2>
<p>interface Workable</p>
<p>{</p>
<p>public function work():void</p>
<p>}</p>
<hr>
<p>final class Programmer implements Workable</p>
<p>{</p>
<p>public function work(): void</p>
<p>{</p>
<p>echo 'coding an app';</p>
<p>}</p>
<hr>
<h2>2</h2>
<p>final class ProjectManager</p>
<p>{</p>
<p>public function manage(Workable $worker): void</p>
<p>{</p>
<p>$worker->work()</p>
<p>}</p>
<hr>
<h2>3</h2>
<p>final class Tester implements Workable</p>
<p>{</p>
<p>public function work(): void</p>
<p>{</p>
<p>echo 'testing an app';</p>
<p>}</p>
<p>}</p>
<hr>
<h3>Liskov Substitution</h3>
<h5>Дочерние классы должны быть заменяемыми на свои родительские классы</h5>
<h3>Принцип разделения интерфейса</h3>
<p>Когда вы обнаруживаете, что создаете интерфейсы, которые не полностью реализованы в их клиентах, вы
    нарушаете принцип разделения интерфейсов. Основная цель этого принципа - сделать интерфейсы. Разделение интерфейсов
    и принцип единой ответственности дополняют друг друга. Они служат той же цели: обеспечивают небольшие,
    очень сплоченные блоки. Принцип разделения интерфейса обеспечивает что интерфейсы небольшие,
    а принцип единой ответственности гарантирует, что классы будут небольшими.</p>
<hr>
<h3>Dependency Inversion Principle</h3>
<h5>Модули высокого уровня не должны зависеть от модулей низкого уровня</h5>
<p>100</p>-->

</body>
</html>