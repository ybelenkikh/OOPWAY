<!doctype html>
<html lang="en" style="font-size: calc(0.645vh + 0.45em);">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">

</head>
<body style="font-family: sans-serif">
<h2>PHP OOP Way Sergey Zhuk</br>
    This book is for sale at <a href="http://leanpub.com/phpoopway">http://leanpub.com/phpoopway</a></br>
    This version was published on 2019-06-21</br>
    © 2017 - 2019 Sergey Zhuk</h2>
<hr>
<h1>Fundamentals</h1>
<div class="bundlePropertiesWithMethods section">
    <h4>Инкапсуляция - сокрытие деталей объекта от внешнего мира и предоставление общедоступного интерфейса для взаимодействия с этим объектом</h4>
    <div class="parent">
        <div class="section--class Class">
            <p>class User</p>
            <p>{</p>
            <p class="p-l yellow ">private $name;</p>
            <p class="p-l yellow ">private $email;</p>
            <p class="p-l yellow  pb-1">private $age;</p>
            <p class="p-l">public function __construct(string $name, string $email, int $age)</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->name = $name;</br> $this->email = $email;</br> $this->setAge($age);</p>
            <p class="p-l">}</p>
            <p class="p-l green">public function getAge():int</p>
            <p class="p-l">{</p>
            <p class="p-l-1 green">return $this->age;</p>
            <p class="p-l">}</p>
            <p class="p-l green">public function setAge(int $age):self</p>
            <p class="p-l">{</p>
            <p class="p-l-1 green">return $this->age = abs($age);</p>
            <p class="p-l">}</p>
            <p class="p-l green">public function isYoung():bool</p>
            <p class="p-l">{</p>
            <p class="p-l-1 green">return $this->age < 18;</p>
            <p class="p-l">}</p>

            <p>}</p>
        </div>
        <div class="description">
            <p class="green">1. Связать <i class="yellow">данные</i> с методами.</p>
            <p class="yellow">2. Ограничить возможность неправильного использования нашего класса.</p>
            <p class="green">Пользователи класса могут взаимодействовать с ним,
                с помощью его методов, </p>
            <p class="yellow">но не могут напрямую получить доступ к состоянию этого класса.</p>
        </div>
    </div>
</div>
<hr>
<hr>
<div class="defineANewType section">
    <h4>Абстракция</h4>
    <div class="parent">
        <div class="section--class abstractClass ">
            <p>abstract class AbstractClass</p>
            <p>{</p>
            <p class="p-l">// нельзя создать объекты абстрактного класса</p>
            <p class="p-l">// в дочернем классе необходимо определить все абстрактные методы обязательно</p>
            <p class="">}</p>
        </div>
        <div class="description">
            <p>Абстракция -
                это удаление ненужных деталей,
                чтобы описать что-то более простым языком.
                Чтобы сосредоточиться только на важных
                аспектах текущего контекста.</p>
            <p>С помощью абстрактного класса мы определяем новый тип данных, который имеет собственный
                интерфейс.</p>
        </div>
    </div>
</div>
<hr>
<hr>
<div class="differentTypesWithTheSameBehavior section">
    <h4>Интерфейс - это гарантия между программистом и его кодом</h4>
    <div class="parent">
        <div class="">
            <div class="section--class interface">
                <p>interface Flyable</p>
                <p>{</p>
                <p class="p-l">public function fly(int $distance);</p>
                <p class="p-l">{</p>
                <p class="p-l">}</p>
                <p class="pb-1">}</p>
            </div>
            <div class="section--class Class">
                <p>final class Bird implements Flyable</p>
                <p>{</p>
                <p class="p-l">public function fly(int $distance)</p>
                <p class="p-l">{</p>
                <p class="p-l">}</p>
                <p class="pb-1">}</p>
            </div>
        </div>
        <div class="description">
            <p>1. Различие интерфейсов с классами заключается во множественном наследовании, которое доступно для интерфейсов</p>
            <div class="section--class interface">
                <p>interface LoggerInterface extends WritableInterface, ReadableInterface</p>
                <p>{</p>
                <p>}</p>
            </div>
            <p>2. Интерфейс предоставляет только публичное объявление методов. Гарантия на код клиента
            который взаимодействует с объектами, реализующими этот интерфейс.</p>
        </div>
    </div>
</div>
<hr>
<hr>
<div class="familiesOfRelatedTypes section">
    <h4>Наследование</h4>
    <div class="parent">
        <div class="section--class Class">
            <p>class Task</p>
            <p>{</p>
            <p class="p-l">private $isClosed;</p>
            <p class="p-l pb-1">private $closedAt;</p>
            <p class="p-l">public function close()</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->isClosed = true;</p>
            <p class="p-l-1">$this->closedAt = date("Y-d-m H:i:s");</p>
            <p class="p-l-1">return $this;</p>
            <p class="p-l">}</p>
            <p class="pb-1">}</p>
            <p>class Project extends Task</p>
            <p>{</p>
            <p class="p-l">public function close</p>
            <p class="p-l">{</p>
            <p class="p-l-1">parent::close();</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="section--class description">
            <div class="Class">
                <p>class User</p>
                <p>{</p>
                <p class="p-l">public function completeTask(Project $project)</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$project->close();</p>
                <p class="p-l">}</p>
                <p>}</p>
                <p>$user->completeTask(new Project());</p>
            </div>
        </div>
    </div>
</div>
<hr>
<hr>
<div class="section">
    <h4>Всегда создавая новый класс, помечайте его
        как final, если только он не предназначен
        специально для расширения</h4>
    <div class="section--class Class">
        <p>final class User</p>
        <p>{</p>
        <p>}</p>
    </div>
</div>
<hr>
<hr>
<div class="traits section">
    <h4>Трейты это механизм повторного использования кода в языках с единичным наследованием, таких как PHP.</h4>
    <div class="parent">
       <div class="section--class Class">
               <p >class Product</p>
               <p>{</p>
               <p class="p-l">private $name;</p>
               <p class="p-l Class--error">public function slug(): string</p>
               <p class="p-l">{</p>
               <p class="p-l-1 Class--error">$cleared = preg_replace( '/[^A-Za-z0-9-]+/', '-', $this->name );</p>
               <p class="p-l-1 Class--error">return strtolower($cleared);</p>
               <p class="p-l pb-1">}</p>
               <p >class Category</p>
               <p>{</p>
               <p class="p-l">private $name;</p>
               <p class="p-l Class--error">public function slug(): string</p>
               <p class="p-l">{</p>
               <p class="p-l-1 Class--error">$cleared = preg_replace( '/[^A-Za-z0-9-]+/', '-', $this->name );</p>
               <p class="p-l-1 Class--error">return strtolower($cleared);</p>
               <p class="p-l">}</p>
               <p>}</p>
               <p class="pb-1 Class--error">// дублирование кода</p>
           <div class="trait">
               <p class="">
                   trait HasSlug
               </p>
               <p>{</p>
               <p class="p-l">public function slug(): string</p>
               <p class="p-l">{</p>
               <p class="p-l-1">$cleared = preg_replace(
                   '/[^A-Za-z0-9-]+/', '-', $this->name
                   );</p>
               <p class="p-l-1">return strtolower($cleared);</p>
               <p class="p-l">}</p>
               <p>}</p>
           </div>
           <p>class Category implements Sluggable</p>
           <p>{</p>
           <p class="p-l">use HasSlug;</p>
           <p class="p-l pb-1">private $name;</p>
           <p class="p-l ">protected function getStringForSlug(): string</p>
           <p class="p-l">{</p>
           <p class="p-l-1">return $this->name;</p>
           <p class="p-l">}</p>
           <p class="p-l">public function parent(): self</p>
           <p class="p-l">{</p>
           <p class="p-l">}</p>
           <p class="p-l">public function products(): array</p>
           <p class="p-l">{</p>
           <p class="p-l">}</p>
           <p class="pb-1">}</p>
           <p>class Product implements Sluggable</p>
           <p>{</p>
           <p class="p-l">use HasSlug;</p>
           <p class="p-l">private $name;</p>
           <p class="p-l">private $shortName;</p>
           <p class="p-l">protected function getStringForSlug(): string</p>
           <p class="p-l">{</p>
           <p class="p-l-1">return $this->shortName;</p>
           <p class="p-l">}</p>
           <p>}</p>
       </div>
        <div class="description">
            <p>1. Убрать дублирование
                из классов</p>
        </div>
        </div>
    </div>
</div>

<!--
          <div class="Class">

            </div>
        </div>
        <div class="description">
            <p>Трейты - это механизм повторного использования кода в языках с единичным наследованием, таких как PHP</p>
            <p>Трейты позволяют нам извлекать тесно связанную группу методов
            в единый многоразовый
                item. А потом этот item можно вставлять в классы.</p>
            <p>Трейты - очень мощный и гибкий инструмент в языках без множественного
            наследования.
                Они могут улучшить кодовую базу и убрать дублирование
                из классов. Но с другой стороны,
                они могут усложнить или даже сломать приложение
                 при неосторожном использовании.</p>
            <div class="Trait">
                <p>trait HasSlug</p>
                <p>{</p>
                <p>public function slug(): string</p>
                <p>{</p>
                <p>$string = $this->getStringForSlug();</p>
                <p>
                    if (!property_exists($this, 'name')) {
                    throw new Exception(
                    'No property "name" to create slug'
                    );</p>
                <p>$cleared = preg_replace(
                    '/[^A-Za-z0-9-]+/', '-', $string
                    );</p>
                <p>return strtolower($cleared);</p>
                <p>}</p>
                <p>abstract protected function getStringForSlug(): string;</p>
                <p>}</p>
            </div>


</div>-->
<hr>
<div class="polymorphism">
    <h2>Полиморфизм</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
            final class
                <p>final class Application</p>
                <p>{</p>
                <p class="p-l">private $cache;</p>
                <p class="p-l">public function setCache(Cache $cache): void</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->cache = $cache;</p>
                <p class="p-l">}</p>
                <p class="p-l">public function flushCache()</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->cache->flush();</p>
                <p class="p-l">}</p>
                <p>}</p>
                <div class="abstractClass">
                    <p>abstract class Cache</p>
                    <p>{</p>
                    <p class="p-l">abstract public function flush(): void;</p>
                    <p>}</p>
                </div>
                <p>final class MemcacheCache extends Cache</p>
                <p>{</p>
                <p class="p-l">public function flush(): void</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->memcache->flush();</p>
                <p class="p-l">}</p>
                <p>}</p>
            <p>final class RedisCache extends Cache</p>
            <p>{</p>
            <p class="p-l">public function flush(): void</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->redis->flush();</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <p>Subtype Polymorphism</p>
            <p>В терминах ООП это означает, что когда у нас есть методы в разных классах,
                которые делают похожие вещи, мы должны дать этим методам одно и то же имя.</p>
            <p> За одним именем мы спрятали разную логику, поэтому можем смело добавлять новые
                реализации, и каждый класс, который знает это имя, автоматически знает, как сотрудничать
                с новыми реализациями.</p>
            <p>           разные классы выполняют одинаковые действия, но не предоставляют общие
                интерфейс
            </p>
        </div>
    </div>
</div>
<hr>
<div class="dependencyInjection">
    <h2>Инъекция зависимостей</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
          <div class="error">
              <p>final class QueryBuilder</p>
              <p>{</p>
              <p class="p-l">public function execute(string $sql, array $params):void</p>
              <p class="p-l">{</p>
              <p class="p-l-1">$logger = new Logger();</p>
              <p class="p-l-1">$logger->info('DB:' . $sql . ';' . implode(',', $params));</p>
              <p class="p-l">}</p>
              <p>}</p>
          </div>
        </div>
        <div class="description">
            <p>В объектно-ориентированном приложении объекты постоянно взаимодействуют друг с другом,
                либо вызывая методы и получая информацию от другого объекта, либо изменяя состояние
                объекты. В любом случае объекты часто зависят друг от друга.</p>
            <p class="error">Если изменится конструктор класса Logger, добавится параметр $filename.
                Все запросы к базе данных перестанут работать. Одно небольшое изменение приводит
                к сбою всего приложения. Конечно, изменение конструктора класса в производственном
                коде уже является сильным признаком плохого дизайна приложения.</p>
        </div>
    </div>
</div>
<div class="hardcodedDependencies">
    <h2>Hard-coded dependencies</h2>
    <h4>Dependency Inversion Principle</h4>
    <div class="parent">
        <div class="Class">
            <p>final class QueryBuilder</p>
            <p>{</p>
            <p class="p-l">public function execute(string $sql, array $params, <b>Logger $logger = null</b>):void</p>
            <p class="p-l">{</p>
            <p class="p-l">if($logger)</p>
            <p class="p-l-1">$logger->info(</p>
            <p class="p-l-1">'DB:' . $sql . ';' . implode(',', $params)</p>
            <p class="p-l-1">);</p>
            <p class="p-l">}</p>
            <p class="pb-1">}</p>
            <hr>
            <p>final class Delivery</p>
            <p>{</p>
            <p class="pb-1 p-l">private $client;</p>
           <div class="error">
               <p class="p-l">public function __construct()</p>
               <p class="p-l">{</p>
               <p class="p-l-1">$this->client = new HttpClient();</p>
               <p class="p-l">}</p>
           </div>
            <p class="p-l">public function send(Order $order): array</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$response = $this->client
                ->post('/orders/create', $order->toJson());</p>
            <p class="p-l-1">return json_decode($response, true);</p>
            <p class="p-l">}</p>
            <p class="p-l">public function getStatus(int $orderId): array</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$response = $this->client
                ->get('/orders/info', $orderId);</p>
            <p class="p-l-1">return json_decode($response, true);</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <p>передать его в качестве аргумента</p>
            <p> + </br>
                • Мы не зависим от сигнатуры конструктора класса Logger.</br>
                • Мы не зависим от конкретной реализации. Мы можем расширить Logger с помощью InMemoryLogger
                и безопасно им пользоваться.</br>
                • Мы можем имитировать регистратор в целях тестирования.</p>
            <p><b>
                Когда мы передаем зависимость в качестве аргумента методу или конструктору, мы вводим ее. Эта техника
                называется внедрением зависимостей. Вместо того, чтобы жестко кодировать наши зависимости, мы внедряем их в объект,
                который их использует.</b></p>
            <p class="">Вот эмпирическое правило: если объект
                нельзя использовать без зависимости, эту зависимость следует передать
                как аргумент конструктора</p>
            <div class="Class">
                <p>public function __construct(HttpClient $client)</p>
                <p>{</p>
                <p class="p-l">$this->client = $client;</p>
                <p>}</p>
            </div>
        </div>
    </div>
</div>
<div class="ConstructorOrSetterInjection">
    <h2>Constructor Or Setter Injection</h2>
    <h4>Но почему мы должны использовать конструктор для внедрения зависимостей?</h4>
    <h5>Может, лучше используйте метод withClient() и настройте объект после создания</h5>
    <h6>Антипаттерн</h6>
    <div class="parent">
        <div class="Class">
           <div class="error pb-1">
               <p>public function withClient(HttpClient $client): void</p>
               <p>{</p>
               <p class="p-l">$this->client = $client;</p>
               <p>}</p>
           </div>
           <div class="error">
               <p>final class DeliveryController</p>
               <p>{</p>
               <p>private $delivery;</p>
               <p>public function __constructor(Delivery $delivery)</p>
               <p>{</p>
               <p>$this->delivery = $delivery;</p>
               <p>}</p>
               <p>public function sendOrder(int $orderId): void</p>
               <p>{</p>
               <p>$order = Order::find($orderId);</p>
               <p>$delivery->sendOrder($order);</p>
               <p>}</p>
               <p>}</p>
               <p>$delivery = new Delivery();</p>
               <p>$controller = new DeliveryController($delivery);</p>
               <p>$controller->sendOrder(111);</p>
           </div>
        </div>
        <div class="description">
            <p>Эмпирическое правило для setter injection: используйте dependency injection setter,
                которые не требуются для объекта. Эти зависимости не должны заменять
                функциональность внутреннего объекта, а должны расширять его.</p>
        </div>
    </div>
</div>
<div class="dependencyInjectionContainer">
    <h2>Dependency Injection Container</h2>
    <h4>Где нам создавать все эти зависимости?</h4>
    <div class="parent">
        <div class="Class">
            <p>final class Container</p>
            <p>{</p>
            <p class="p-l">public function makeDelivery(): Delivery</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$httpClient = new HttpClient(
                'http://some-api.com'
                );</p>
            <p class="p-l-1">return new Delivery(</p>
            <p class="p-l-1">$httpClient, $logger</p>
            <p class="p-l-1">);</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <p><a href="http://symfony.com/doc/current/components/dependency_injection.html">Symfony Component Dependency Injection</a></p>
        </div>
    </div>
</div>
<div class="dependencyInjectionSmells">
    <h2>Как не использовать!</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
           <div class="error">
               <p>public function __construct(</p>
               <p class="p-l">OrdersRepository $ordersRepo,</p>
               <p class="p-l">PaymentGateway $payments,</p>
               <p class="p-l">ShippingService $shipping,</p>
               <p class="p-l">Logger $logger,</p>
               <p class="p-l">Email $mailer</p>
           </div>
        </div>
        <div class="description">
            <p>Слишком много зависимостей
                Когда у класса много зависимостей в конструкторе это первый признак того, что
                этот класс имеет слишком много обязанностей (нарушает Single Responsibility Principle<sup><b>S</b>OLID</sup>)</p>
            <p>Другой вариант - передать конструктору только контейнер, а затем разрешить все эти
                зависимости - <b>anti-pattern Service Locator</b></p>
        </div>
    </div>
</div>
<div class="closure">
    <h2>Замыкание</h2>
    <h5>
        Замыкание - это анонимная функция, которую можно сохранить в переменной
        и передать в качестве аргумента в другие функции или методы.
        Замыкания дают нам новую функциональность и возможность рефакторинга старого кода.</h5>
    <div class="parent">
        <div class="Class">
            <p>$heyFunc = function($name){</p>
            <p class="p-l">return "Hey, {$name}";</p>
            <p>}</p>
            <div class="error pb-1">
                <p>$var = 'hello';</p>
                <p>$func = function () {</p>
                <p class="p-l">echo $var;</p>
                <p>};</p>
            </div>
            <p>$var = 'hello';</p>
            <p>$func = function () use ($var) {</p>
            <p>echo $var;</p>
            <p>};</p>
            <p class="pb-1">$func(); // hello</p>

        </div>
        <div class="description">
            <p>Замыкание имеет отдельное пространство имен</p>
            <p>Изменение этих переменных
                внутри замыкания не имеет внешнего эффекта,
                если эти переменные не являются объектами (объекты всегда передаются по ссылке)</p>
            <div class="Class">
                <p>$var = 'hello';</p>
                <p>$func = function () use ($var) {</p>
                <p>echo $var = 'hi';</p>
                <p>};</p>
                <p class="pb-1">$func(); // hello</p>
            </div>
            <p>
                Если мы хотим изменить переменную $var, мы должны добавить амперсанд для передачи этой переменной по ссылке,
                как это:</p>
            <div class="Class">
                <p>$var = 'hello';</p>
                <p>$func = function () use (<b>&</b>$var) {</p>
                <p>echo $var = 'hi';</p>
                <p>};</p>
                <p class="pb-1">$func(); // hello</p>
            </div>
            <p>Когда мы создаем анонимную функцию и назначаем ее переменной, PHP превращает ее в объект
                класс Closure. Класс Closure - это особый класс. Мы не можем создать его экземпляры</p>
        </div>
    </div>

</div>
<hr>
<h1>SOLID Principles</h1>
<div class="solid">
    <div class="s solid__item">
        <h1>S</h1>
        <p>single responsibility</p>
        <p>принцип единичной ответственности</p>
        <p>цель - создать небольшие полезные классы, которые должны нести единственную ответственность</p>
        <div class="Class t-a-l">
            <div class="error">
                <p>class Category</p>
                <p>{</p>
                <p class="p-l">public function addProduct(Product $product): self</p>
                <p class="p-l">{</p>
                <p class="p-l-1">if (auth()->user() instanceof Admin) {</p>
                <p class="p-l-1">throw new UnAuthorizedException;</p>
                <p class="p-l-1">return $this;</p>
                <p class="p-l">}</p>
                <p>}</p>
                <p class="pb-1">Сколько обязанностей имеет class Category даже с этим маленьким образцом кода? Как минимум два:
                    addProduct и
                    проверка подлинности user.</p>
            </div>
            <p>class Category</p>
            <p>{</p>
            <p class="p-l">public function addProduct(Product $product): self</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return $this;</p>
            <p class="p-l">}</p>
            <p>}</p>

    </div>
    </div>
    <div class="o solid__item">
        <h1>O</h1>
        <p>open-close</p>
        <p>принцип открытости закрытости</p>
        <p>Программные объекты (классы, модули, функции и т. Д.) Должны быть открыты для расширения, но закрыты
            для модификации.</p>
        <div class="Class t-a-l">
            <div class="interface">
                <p>interface Workable</p>
                <p>{</p>
                <p class="p-l">public function work():void</p>
                <p>}</p>
            </div>
            <p>final class Programmer implements Workable</p>
            <p>{</p>
            <p class="p-l">public function work(): void</p>
            <p class="p-l">{</p>
            <p class="p-l-1">echo 'coding an app';</p>
            <p class="pb-1 p-l">}</p>
            <p>final class Tester implements Workable</p>
            <p>{</p>
            <p class="p-l">public function work(): void</p>
            <p class="p-l">{</p>
            <p class="p-l-1">echo 'testing an app';</p>
            <p class="p-l">}</p>
            <p class="pb-1">}</p>
            <p>final class ProjectManager</p>
            <p>{</p>
            <p class="p-l">public function manage(Workable $worker): void</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$worker->work()</p>
            <p class="p-l">}</p>
            <p>}</p>
            <p>Смысл принципа Open-Closed довольно прост: конструкция вашей системы должна быть
                проста и устойчива к изменениям. Это означает, что при изменении требований мы должны
                быть готовы.
                Это не означает, что мы должны создавать ненужные уровни абстракции, когда у нас есть только одна
                реализация интерфейса. Нам просто нужно ограничить каскад изменений и свести их к
                минимум. Мы можем добиться этого, извлекая расширяемое поведение за интерфейсом и скрывая
                детали реализации из клиентского кода.</p>
        </div>
    </div>
    <div class="l solid__item">
        <h1>L</h1>
        <p>Liskov Substitution</p>
        <p>Three Rules to Respect Liskov Substitution Principle</p>
        <p>Дочерние классы должны быть заменены на их родительские классы</p>
        <p>Когда класс использует реализацию интерфейса, он должен иметь возможность использовать любую реализацию этого
            интерфейс без каких-либо доработок</p>
        <h5>1.</h5>
        <div class="Class">
            <div class="t-a-l interface">
                <p>interface Cacheable</p>
                <p>{</p>
                <p class="p-l">public function get($key)</p>
                <p class="p-l">public function set($key, $value);</p>
                <p>}</p>
            </div>
            <div class="t-a-l">
                <p>final class CatalogController</p>
                <p>{</p>
                <p class="p-l">public function gifts(Cacheable $cache): View</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$categories = $cache->get('giftsCategories');</p>
                <p class="p-l">}</p>
                <p>}</p>
            </div>
            <p>Здесь мы не привязаны к конкретному механизму кеширования, и мы можем изменить его, не касаясь
                логика контроллеров. Мы можем реализовать DatabaseCache, RedisCache или даже FileCache, и все будет
                продолжать работать.</p>
            <div class="t-a-l">
                <p>final class CatalogController</p>
                <p>{</p>
                <p class="p-l">public function gifts ($cache): View</p>
                <p class="p-l">{</p>
                <p class="p-l-1">if ($cache instanceof DatabaseCache) {</p>
                <p class="p-l-1">//..</p>
                <p class="p-l-1">} elseif ($cache instanceof RedisCache) {</p>
                <p class="p-l-1">//..</p>
                <p class="p-l-1">} elseif ($cache instanceof FileCache) {</p>
                <p class="p-l-1">//..</p>
                <p class="p-l-1">}</p>
                <p class="p-l">}</p>
                <p>}</p>
            </div>
        </div>
        <h5>2.</h5>
        <p>Дочерние классы никогда не должны нарушать
            определения типов родительского класса!</p>
       <div class="Class">
           <div class="abstractClass t-a-l">
               <p>abstract class Vehicle</p>
               <p>{</p>
               <p>public function drive(){}</p>
               <p>public function fuel(){}</p>
               <p>}</p>
           </div>
           <div class="t-a-l">
               <p>final class Car extends Vehicle</p>
               <p>{</p>
               <p>}</p>
               <p>final class Bike extends Vehicle</p>
               <p>{</p>
               <p>}</p>
           </div>
           <p>Следует позаботиться о том, чтобы дочерние методы были совместимы со спецификацией родителя. Есть
               три правила для достижения этого.</p>
           <p>1. Первое правило касается параметров - замещающих методов</p>
           <div class="abstractClass t-a-l">
               <p>abstract class Mechanic</p>
               <p>{</p>
               <p class="p-l">public function fixVehicle(Bike $bike)</p>
               <p class="p-l">{</p>
               <p class="p-l-1">return $bike;</p>
               <p class="p-l">}</p>
               <p>}</p>
           </div>
           <div class="Class t-a-l">
               <p>final class Bike extends Vehicle</p>
               <p>{</p>
               <p>}</p>
           </div>
           <div class="abstractClass t-a-l">
               <p>abstract class Vehicle</p>
               <p>{</p>
               <p>}</p>
           </div>
           <div class="Class t-a-l">
               <p>final class SportBikeMechanic extends Mechanic</p>
               <p>{</p>
               <p class="p-l">public function fixVehicle(Bike $bike)</p>
               <p class="p-l">{</p>
               <p class="p-l-1">return $bike;</p>
               <p class="p-l">}</p>
               <p>}</p>
           </div>
           <p>2.</p>
           <p>Возвращаемые значения</p>
          <div class="t-a-l">
              <div class="abstractClass">
                  <p>abstract class BikeFactory</p>
                  <p>{</p>
                  <p class="p-l">public function makeBike(): Bike</p>
                  <p class="p-l">{</p>
                  <p class="p-l-1">return new Bike;</p>
                  <p class="p-l">}</p>
                  <p class="pb-1">}</p>
              </div>
              <p>final class SportBikeFactory extends BikeFactory</p>
              <p>{</p>
              <p class="p-l">public function makeBike(): Bike</p>
              <p class="p-l">{</p>
              <p class="p-l-1">return new SportBike();</p>
              <p class="p-l">}</p>
              <p>}</p>
              <p>class SportBikeFactory</p>
              <p>{</p>
              <p class="p-l">public function makeBike(): Bike</p>
              <p class="p-l">{</p>
              <p class="p-l-1">return new Vehicle();</p>
              <p class="p-l">}</p>
              <p>}</p>
          </div>
           <p>3.</p>
           <p>Exception</p>
           <p>Переопределенные методы в дочерних классах должны выдавать такие же или более специализированные
               исключения</p>
           <p>Как правило говорит
               всегда возвращать исключения того же типа или более специализированные</p>
           <hr>
           <p>Принцип замены Лискова заключается в соблюдении контракта независимо от того, что мы используем: интерфейсы и
               классы или иерархию наследования. Цель принципа - создавать замещаемые классы, поэтому мы
               можем использовать любой из них, и все должно продолжать работать отлично.</p>
       </div>
    </div>
    <div class="i solid__item">
        <h1>I</h1>
        <p>Interface Segregation</p>
        <p>принцип разделение интерфейса</p>
        <p>Принцип гласит, что вместо одного толстого интерфейса лучше использовать несколько
            меньших интерфейсов</p>
        <p>Основная цель этого принципа - сделать интерфейсы небольшими.</p>

    </div>
    <div class="d solid__item">
        <h1>D</h1>
        <p>Dependency Inversion</p>
        <p>полагаться на абстракции</p>
        <p>Основная идея состоит в том, что ваши классы высокого уровня никогда не должны зависеть 
            от классов низкого уровня. Или другими словами, класс никогда не должен зависеть от конкретных реализаций,
            вместо этого он должен зависеть от абстракции или интерфейсов.</p>
        <div class="Class t-a-l">
            <div class="interface">
                <p>interface Workable</p>
                <p>{</p>
                <p>public function work(): void;</p>
                <p>}</p>
            </div>
            <p>final class Programmer implements Workable</p>
            <p>{</p>
            <p class="p-l">public function work(): void</p>
            <p class="p-l">{</p>
            <p class="p-l-1">// ... code</p>
            <p class="p-l pb-1">}</p>
            <p>final class ProjectManager</p>
            <p>{</p>
            <p class="p-l">public function manage(Workable $worker): void</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$worker->work();</p>
            <p class="p-l">}</p>
            <p>}</p>
            <p>final class Tester implements Workable</p>
            <p>{</p>
            <p>public function work(): void</p>
            <p>{</p>
            <p>// ... testing</p>
            <p>}</p>
            <p>}</p>
        </div>

    </div>
</div>
<hr>
<h1 class="centered">object-oriented design</h1>
<p>Объектно-ориентированные приложения состоят из объектов и связей между ними. Когда один объект
    отправляет сообщение другому, это означает, что отправитель что-то знает о получателе. В другом
    словами, отправитель зависит от получателя и наоборот. Итак, когда мы говорим об объектно-ориентированном дизайне,
    мы имеем в виду эти зависимости между объектами в нашем приложении. Объектно-ориентированный Дизайн - это набор методов,
    которые помогут вам управлять зависимостями ваших объектов. Плохой дизайн ведет к неуправляемым зависимостям,
    когда объекты слишком много знают друг о друге. Одно простое изменение может каскадировать все зависимости и
    что-то сломать. Кроме того, когда объект знает слишком много, его трудно повторно использовать или протестировать.

    Сам дизайн - это не набор правил, которым нужно следовать. Это искусство упорядочивания кода, классов и
    их зависимостей. Мы рассмотрим некоторые передовые практики, правила и рекомендации по дизайну,
    но это не значит, что их автоматическое выполнение улучшит ваш дизайн. Рассмотреть возможность
    их только как рекомендации. Все эти правила могут быть нарушены, и вы можете решить, что в некоторых
    случаи лучше пропустить, чем следовать. Это не законы, которые нельзя нарушать.
    По крайней мере, главная цель хорошего дизайна - облегчить изменение кода, поскольку требования
    всегда меняются. Приложения, которые сопротивляются изменениям, всегда очень дороги в обслуживании, и каждый
    новое изменение увеличивает эту стоимость, что приводит к техническому долгу.</p>
<p>
    Всегда думайте, прежде чем создавать новый класс или интерфейс. Не добавляйте лишней сложности
    и уровней абстракции к системе, когда есть простое решение. Помните, что большинство
    этих принципов могут быть очень полезны в огромных, ультраконфигурируемых, сложных корпоративных системах. Для
    такого рода приложений должны потребоваться принципы SOLID, чтобы эти приложения были надежными и
    ремонтопригодный. Но в небольших конкретных приложениях эти принципы могут вообще не улучшить дизайн.
</p>
<h6>Всегда. Изменения неизбежны, и наша задача - сделать наши приложения
    легко изменяемыми.</h6>
<h2>Tell Don’t Ask (Скажите, не спрашивайте)</h2>
<p><b>Процедурный код получает информацию, а затем принимает решения. Объектно-ориентированный код говорит объектам что-то делать.
    - Алек Шарп</b>.</p>
<p>Examples of issues(Примеры проблем)</p>
<div class="parent">
    <div class="Class error">
        <p>final class InvoiceController</p>
        <p>{</p>
        <p class="p-l">public function payAction():View</p>
        <p class="p-l">{</p>
        <p class="p-l-1">$userBalance = $user->getBalance();</p>
        <p class="p-l-1">if($userBalance < $invoiceTotal){</p>
        <p>throw new NotEnoughFundsException();</p>
        <p>}</p>
        <p class="p-l">$newBalance = $userBalance - $invoiceTotal;</p>
        <p class="p-l-1">$user->setBalance($newBalance);</p>
        <p class="p-l">}</p>
        <p>}</p>
    </div>
    <div class="description">
        <p> это очень часто можно встретить, где клиентский код запрашивает данные у модели, а затем исп их для принятия
        логического решения на основе этих значений</p>
       <p>рассмотрим сам объект User</p>
        <p>Должно ли быть public свойство balance?</p>
        <p>Должны ли передать сеттер свойства клиентскому коду?</p>
        <p>Правильно ли, что в любой части нашего приложения мы можем просто вызвать $user->setBalance()
            и поменять его?</p>
        <p>Конечно нет!</p>

    </div>
</div>
<div class="parent">
    <div class="Class">
        <p>final class User</p>
        <p>{</p>
        <p class="p-l">public function payInvoice($sum): self</p>
        <p class="p-l">{</p>
        <p class="p-l-1">if ($this->balance < $sum) {
            throw new NotEnoughFundsException();
            }</p>
        <p class="p-l-1">$this->balance -=$sum;</p>
        <p class="p-l-1">return $this;</p>
        <p class="p-l">}</p>
        <p class="pb-1">}</p>
        <p>final class InvoiceController</p>
        <p>{</p>
        <p class="p-l">public function payAction(): View</p>
        <p class="p-l">{</p>
        <p>try {</p>
        <p>$user->payInvoice($invoice->getTotal());</p>
        <p>} catch (NotEnoughFundsException $e){</p>
        <p>}</p>
        <p class="p-l">}</p>
        <p>}</p>
    </div>
    <div class="description">
        <h4>Помните: действия в контроллерах не должны напрямую изменять свойства объекта модели.
            Действия должны вызывать события, а не делать работу сами.</h4>
       <p>Принцип «говори, не спрашивай»</p>
    </div>
</div>
<h4>Завистливые функци</h4>
<div class="parent">
    <div class="Class error">
        <p>final class Admin</p>
        <p>{</p>
        <p class="p-l">public function closeOrder(Order $order): void</p>
        <p class="p-l">{</p>
        <p class="p-l-1">if ($order->isPaid()) {</p>
        <p class="p-l-1">$order->setStatus('closed');</p>
        <p class="p-l-1">$order->setResponsibleUser($this->id);</p>
        <p>}</p>
        <p class="p-l">}</p>
        <p>}</p>
    </div>
    <div class="description">
        <p>когда один класс использует множество методов другого класса</p>
        <p>Объект всегда должен нести ответственность за изменение своего состояния</p>
        <p>Мы можем использовать принцип «Говори, не спрашивай», чтобы решить эту проблему. Здесь мы сделали две ошибки:
            сначала мы спрашиваем приказ о его состоянии и затем в соответствии с ответом меняем это состояние. Будет хорошо
            сделать это в классе Order. Но теперь похоже, что класс Admin больше интересуется состоянием заказа, чем
            Сам заказ. Объект всегда должен нести ответственность за изменение своего состояния:</p>
    </div>
</div>
<div class="parent">
    <div class="Class">
        <p>final class Admin</p>
        <p>{</p>
        <p class="p-l">public function closeOrder(Order $order): void</p>
        <p class="p-l">{</p>
        <p class="p-l-1">$order->close($this->id);</p>
        <p class="p-l">}</p>
        <p>}</p>
        <p>final class Order</p>
        <p>{</p>
        <p class="p-l">public function close($resposibleUserId): void</p>
        <p class="p-l">{</p>
        <p class="p-l-1">if ($this->isPaid()) {</p>
        <p class="p-l-1">$this->status = self::CLOSED;</p>
        <p class="p-l-1">$this->responsibleUserId = $resposibleUserId;</p>
        <p class="p-l">}</p>
        <p>}</p>
    </div>
</div>
<hr>
<h1>112</h1>

</body>
</html>