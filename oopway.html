<!doctype html>
<html lang="en" style="font-size: calc(0.645vh + 0.45em);">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">

</head>
<body style="font-family: sans-serif">
<h2>PHP OOP Way Sergey Zhuk</br>
    This book is for sale at <a href="http://leanpub.com/phpoopway">http://leanpub.com/phpoopway</a></br>
    This version was published on 2019-06-21</br>
    © 2017 - 2019 Sergey Zhuk</h2>
<hr>
<h1>Fundamentals</h1>
<div class="bundlePropertiesWithMethods">
    <h2>Связывание свойств с методами</h2>
    <h4>Инкапсуляция</h4>
    <div class="parent">
        <div class="Class">
            <p>class User</p>
            <p>{</p>
            <p class="p-l">private $name;</p>
            <p class="p-l">private $email;</p>
            <p class="p-l pb-1">private $age;</p>
            <p class="p-l">public function __construct(string $name, string $email, int $age)</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->name = $name;</br> $this->email = $email;</br> $this->setAge($age);</p>
            <p class="p-l">}</p>
            <p class="p-l">public function getAge():int</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return $this->age;</p>
            <p class="p-l">}</p>
            <p class="p-l">public function setAge(int $age):self</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return $this->age = abs($age);</p>
            <p class="p-l">}</p>
            <p class="p-l">public function isYoung():bool</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return $this->age < 18;</p>
            <p class="p-l">}</p>

            <p>}</p>
        </div>
        <div class="description">
            <p>Основная идея инкапсуляции - связать данные с методами.</p>
            <p>Основная цель - ограничить возможности неправильного использования нашего класса.</p>
            <p>Считайте инкапсуляцию сокрытием деталей объекта от внешнего мира и
                предоставление общедоступного интерфейса для взаимодействия с этим
                объектом</p>
            <p>Инкапсуляция - это метод, используемый как часть абстракции. Инкапсуляция касается состояния объектов
                когда они скрывают это от внешнего мира. Пользователи класса могут взаимодействовать с ним с помощью его методов, но
                не может напрямую получить доступ к своему состоянию.</p>
        </div>
    </div>
</div>
<hr>
<div class="defineANewType">
    <h2>Определение нового типа данных</h2>
    <h4>Абстракция</h4>
    <div class="parent">
        <div class="">
            <p class="pb-1">Новый абстрактный класс определяет интерфейс для этого нового типа данных. Когда мы предоставляем общедоступные методы
                мы говорим: «Эй, с переменной этого типа данных вы можете сделать это, и она будет вести себя в этом
                определенный способ". Это очень важно, когда мы рассматриваем класс как тип данных. Его публичный интерфейс
                - это набор правил, определяющих способ взаимодействия с этим типом.</p>
            <div class="abstractClass">
                <p>abstract class AbstractClass</p>
                <p>{</p>
                <p>// нельзя создать объекты абстрактного класса</p>
                <p>// в дочернем классе необходимо определить все абстрактные методы обязательно</p>
                <p class="">}</p>
            </div>

        </div>
        <div class="description">
            <p>Абстракция - «это что-то о повторном использовании кода»</p>
            <p>Есть много разных способов добиться повторного использования кода, и наихудший из них - абстракция.</p>
            <p>Абстракция - это удаление ненужных деталей, чтобы описать что-то более простым языком.
                термины, чтобы сосредоточиться только на важных аспектах текущего контекста.</p>
        </div>
    </div>
</div>
<hr>
<div class="familiesOfRelatedTypes">
    <h2>Семейства родственных типов</h2>
    <h4>Наследование</h4>
    <div class="parent">
        <div class="Class">
            <p>class Task</p>
            <p>{</p>
            <p class="p-l">private $isClosed;</p>
            <p class="p-l pb-1">private $closedAt;</p>
            <p class="p-l">public function close()</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->isClosed = true;</p>
            <p class="p-l-1">$this->closedAt = date("Y-d-m H:i:s");</p>
            <p class="p-l-1">return $this;</p>
            <p class="p-l">}</p>
            <p class="pb-1">}</p>
            <p>class Project extends Task</p>
            <p>{</p>
            <p class="p-l">public function close</p>
            <p class="p-l">{</p>
            <p class="p-l-1">parent::close();</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <div class="Class">
                <p>class User</p>
                <p>{</p>
                <p class="p-l">public function completeTask(Project $project)</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$task->close();</p>
                <p class="p-l">}</p>
                <p>}</p>
                <p>$user->completeTask(new Project());</p>
            </div>
        </div>
    </div>
</div>
<hr>
<div class="differentTypesWithTheSameBehavior">
    <h2>Различные типы данных с одинаковым поведением</h2>
    <h4>Интерфейс</h4>
    <div class="parent">
        <div class="Class">
            <div class="interface">
                <p>interface Flyable</p>
                <p>{</p>
                <p class="p-l">public function fly(int $distance);</p>
                <p class="pb-1">}</p>
            </div>
            <p>final class Bird implements Flyable</p>
            <p>{</p>
            <p class="p-l">public function fly(int $distance)</p>
            <p class="p-l">{</p>
            <p class="p-l">}</p>
            <p class="pb-1">}</p>
            <div class="abstractClass">
                <p>abstract class FlyableEntity</p>
                <p>{</p>
                <p class="p-l pb-1">protected $wings;</p>
                <p class="p-l">abstract public function fly(int $distance);</p>
                <p>}</p>
            </div>
        </div>
        <div class="description">
            <p>Интерфейс - это гарантия между программистом и его кодом</p>
            <p>Различие интерфейсов с классами заключается во множественном наследовании, которое доступно для интерфейсов</p>
            <div class="interface">
                <p>interface LoggerInterface extends WritableInterface, ReadableInterface</p>
                <p>{</p>
                <p>}</p>
            </div>
            <hr>
            <p>Абстрактный класс также предоставляет интерфейс. Отличие, что абстрактный класс может предоставить
                логику реализации для своих методов</p>
            <p>final class Bird extends FlyableEntity</p>
            <p>{</p>
            <p class="p-l">public function fly(int $distance)</p>
            <p class="p-l">{</p>
            <p></p>
            <p class="p-l">}</p>
            <p>}</p>
            <p>Эта иерархия предназначена только для того, чтобы продемонстрировать разницу между интерфейс и абстрактный класс.</p>
        </div>
    </div>
</div>
<hr>
<div class="InterfaceVsAbstractClass">
    <h2>Интерфейс. Абстрактный класс.</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
            <div class="abstractClass">
                <p>abstract class Cache</p>
                <p>{</p>
                <p class="p-l">abstract public function get(Cacheable $entity);</p>
                <p class="p-l">abstract public function set(Cacheable $entity);</p>
                <p class="pb-1">}</p>
            </div>
            <div class="interface">
                <p>interface Cacheable</p>
                <p>{</p>
                <p class="p-l">public function getCacheKey();</p>
                <p class="p-l">public function getCacheData();</p>
                <p class="pb-1">}</p>
            </div>
            <p>class Category implements Cacheable</p>
            <p>{</p>
            <p class="p-l">public function getCacheKey(): string</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return 'product_' . $this->id;</p>
            <p class="p-l">}</p>
            <p class="p-l">public function getCacheData(): array</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return [];</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
           <p>При использовании абстрактных классов наши константы могут иметь значения переменных</p>
            <div class="interface">
                <p>interface MathInterface</p>
                <p>{</p>
                <p>const PI = 3.14159;</p>
                <p>}</p>
            </div>
            <p>С помощью абстрактного класса мы определяем новый тип данных, который имеет собственный
                интерфейс.</p>
            <p>Интерфейс предоставляет только публичное объявление методов. Гарантия на код клиента
                который взаимодействует с объектами, реализующими этот интерфейс.</p>
        </div>
    </div>
</div>
<hr>
<div class="traits">
    <h2>Трейты</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
          <div class="error">
              <p>class Product</p>
              <p>{</p>
              <p class="p-l">private $name;</p>
              <p class="p-l">public function slug(): string</p>
              <p class="p-l">{</p>
              <p class="p-l-1">$cleared = preg_replace( '/[^A-Za-z0-9-]+/', '-', $this->name );</p>
              <p class="p-l-1">return strtolower($cleared);</p>
              <p class="p-l pb-1">}</p>
              <p>class Category</p>
              <p>{</p>
              <p class="p-l">private $name;</p>
              <p class="p-l">public function slug(): string</p>
              <p class="p-l">{</p>
              <p class="p-l-1">$cleared = preg_replace( '/[^A-Za-z0-9-]+/', '-', $this->name );</p>
              <p class="p-l-1">return strtolower($cleared);</p>
              <p class="p-l">}</p>
              <p>}</p>
              <p class="pb-1">// дублирование кода</p>
          </div>
          <div class="Class">
                <p>class Category implements Sluggable</p>
                <p>{</p>
                <p class="p-l">use HasSlug;</p>
                <p class="p-l pb-1">private $name;</p>
                <p class="p-l ">protected function getStringForSlug(): string</p>
                <p class="p-l">{</p>
                <p class="p-l-1">return $this->name;</p>
                <p class="p-l">}</p>
                <p class="p-l">public function parent(): self</p>
                <p class="p-l">{</p>
                <p class="p-l">}</p>
                <p class="p-l">public function products(): array</p>
                <p class="p-l">{</p>
                <p class="p-l">}</p>
                <p class="pb-1">}</p>
                <p>class Product implements Sluggable</p>
                <p>{</p>
                <p class="p-l">use HasSlug;</p>
                <p class="p-l">private $name;</p>
                <p class="p-l">private $shortName;</p>
                <p class="p-l">protected function getStringForSlug(): string</p>
                <p class="p-l">{</p>
                <p class="p-l-1">return $this->shortName;</p>
                <p class="p-l">}</p>
                <p>}</p>
            </div>
        </div>
        <div class="description">
            <p>Трейты - это механизм повторного использования кода в языках с единичным наследованием, таких как PHP</p>
            <p>Трейты позволяют нам извлекать тесно связанную группу методов в единый многоразовый
                item. А потом этот item можно вставлять в классы.</p>
            <p>Трейты - очень мощный и гибкий инструмент в языках без множественного наследования.
                Они могут улучшить кодовую базу и убрать дублирование из классов. Но с другой стороны,
                они могут усложнить или даже сломать приложение при неосторожном использовании.</p>
            <div class="Trait">
                <p>trait HasSlug</p>
                <p>{</p>
                <p>public function slug(): string</p>
                <p>{</p>
                <p>$string = $this->getStringForSlug();</p>
                <p>
                    if (!property_exists($this, 'name')) {
                    throw new Exception(
                    'No property "name" to create slug'
                    );</p>
                <p>$cleared = preg_replace(
                    '/[^A-Za-z0-9-]+/', '-', $string
                    );</p>
                <p>return strtolower($cleared);</p>
                <p>}</p>
                <p>abstract protected function getStringForSlug(): string;</p>
                <p>}</p>
            </div>
            <div class="interface">
                <p>interface Sluggable</p>
                <p>{</p>
                <p>public function slug(): string;</p>
                <p>}</p>
                <p>Класс который хочет использовать трейт HasSlug должен реализовывать интерфейс Sluggable.</p>
            </div>
        </div>
    </div>
</div>
<hr>
<div class="polymorphism">
    <h2>Полиморфизм</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
            final class
                <p>final class Application</p>
                <p>{</p>
                <p class="p-l">private $cache;</p>
                <p class="p-l">public function setCache(Cache $cache): void</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->cache = $cache;</p>
                <p class="p-l">}</p>
                <p class="p-l">public function flushCache()</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->cache->flush();</p>
                <p class="p-l">}</p>
                <p>}</p>
                <div class="abstractClass">
                    <p>abstract class Cache</p>
                    <p>{</p>
                    <p class="p-l">abstract public function flush(): void;</p>
                    <p>}</p>
                </div>
                <p>final class MemcacheCache extends Cache</p>
                <p>{</p>
                <p class="p-l">public function flush(): void</p>
                <p class="p-l">{</p>
                <p class="p-l-1">$this->memcache->flush();</p>
                <p class="p-l">}</p>
                <p>}</p>
            <p>final class RedisCache extends Cache</p>
            <p>{</p>
            <p class="p-l">public function flush(): void</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$this->redis->flush();</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <p>Subtype Polymorphism</p>
            <p>В терминах ООП это означает, что когда у нас есть методы в разных классах,
                которые делают похожие вещи, мы должны дать этим методам одно и то же имя.</p>
            <p> За одним именем мы спрятали разную логику, поэтому можем смело добавлять новые
                реализации, и каждый класс, который знает это имя, автоматически знает, как сотрудничать
                с новыми реализациями.</p>
            <p>           разные классы выполняют одинаковые действия, но не предоставляют общие
                интерфейс
            </p>
        </div>
    </div>
</div>
<hr>
<div class="dependencyInjection">
    <h2>Инъекция зависимостей</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
          <div class="error">
              <p>final class QueryBuilder</p>
              <p>{</p>
              <p class="p-l">public function execute(string $sql, array $params):void</p>
              <p class="p-l">{</p>
              <p class="p-l-1">$logger = new Logger();</p>
              <p class="p-l-1">$logger->info('DB:' . $sql . ';' . implode(',', $params));</p>
              <p class="p-l">}</p>
              <p>}</p>
          </div>
        </div>
        <div class="description">
            <p>В объектно-ориентированном приложении объекты постоянно взаимодействуют друг с другом,
                либо вызывая методы и получая информацию от другого объекта, либо изменяя состояние
                объекты. В любом случае объекты часто зависят друг от друга.</p>
            <p class="error">Если изменится конструктор класса Logger, добавится параметр $filename.
                Все запросы к базе данных перестанут работать. Одно небольшое изменение приводит
                к сбою всего приложения. Конечно, изменение конструктора класса в производственном
                коде уже является сильным признаком плохого дизайна приложения.</p>
        </div>
    </div>
</div>
<div class="hardcodedDependencies">
    <h2>Hard-coded dependencies</h2>
    <h4>Dependency Inversion Principle</h4>
    <div class="parent">
        <div class="Class">
            <p>final class QueryBuilder</p>
            <p>{</p>
            <p class="p-l">public function execute(string $sql, array $params, <b>Logger $logger = null</b>):void</p>
            <p class="p-l">{</p>
            <p class="p-l">if($logger)</p>
            <p class="p-l-1">$logger->info(</p>
            <p class="p-l-1">'DB:' . $sql . ';' . implode(',', $params)</p>
            <p class="p-l-1">);</p>
            <p class="p-l">}</p>
            <p class="pb-1">}</p>
            <hr>
            <p>final class Delivery</p>
            <p>{</p>
            <p class="pb-1 p-l">private $client;</p>
           <div class="error">
               <p class="p-l">public function __construct()</p>
               <p class="p-l">{</p>
               <p class="p-l-1">$this->client = new HttpClient();</p>
               <p class="p-l">}</p>
           </div>
            <p class="p-l">public function send(Order $order): array</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$response = $this->client
                ->post('/orders/create', $order->toJson());</p>
            <p class="p-l-1">return json_decode($response, true);</p>
            <p class="p-l">}</p>
            <p class="p-l">public function getStatus(int $orderId): array</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$response = $this->client
                ->get('/orders/info', $orderId);</p>
            <p class="p-l-1">return json_decode($response, true);</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <p>передать его в качестве аргумента</p>
            <p> + </br>
                • Мы не зависим от сигнатуры конструктора класса Logger.</br>
                • Мы не зависим от конкретной реализации. Мы можем расширить Logger с помощью InMemoryLogger
                и безопасно им пользоваться.</br>
                • Мы можем имитировать регистратор в целях тестирования.</p>
            <p><b>
                Когда мы передаем зависимость в качестве аргумента методу или конструктору, мы вводим ее. Эта техника
                называется внедрением зависимостей. Вместо того, чтобы жестко кодировать наши зависимости, мы внедряем их в объект,
                который их использует.</b></p>
            <p class="">Вот эмпирическое правило: если объект
                нельзя использовать без зависимости, эту зависимость следует передать
                как аргумент конструктора</p>
            <div class="Class">
                <p>public function __construct(HttpClient $client)</p>
                <p>{</p>
                <p class="p-l">$this->client = $client;</p>
                <p>}</p>
            </div>
        </div>
    </div>
</div>
<div class="ConstructorOrSetterInjection">
    <h2>Constructor Or Setter Injection</h2>
    <h4>Но почему мы должны использовать конструктор для внедрения зависимостей?</h4>
    <h5>Может, лучше используйте метод withClient() и настройте объект после создания</h5>
    <h6>Антипаттерн</h6>
    <div class="parent">
        <div class="Class">
           <div class="error pb-1">
               <p>public function withClient(HttpClient $client): void</p>
               <p>{</p>
               <p class="p-l">$this->client = $client;</p>
               <p>}</p>
           </div>
           <div class="error">
               <p>final class DeliveryController</p>
               <p>{</p>
               <p>private $delivery;</p>
               <p>public function __constructor(Delivery $delivery)</p>
               <p>{</p>
               <p>$this->delivery = $delivery;</p>
               <p>}</p>
               <p>public function sendOrder(int $orderId): void</p>
               <p>{</p>
               <p>$order = Order::find($orderId);</p>
               <p>$delivery->sendOrder($order);</p>
               <p>}</p>
               <p>}</p>
               <p>$delivery = new Delivery();</p>
               <p>$controller = new DeliveryController($delivery);</p>
               <p>$controller->sendOrder(111);</p>
           </div>
        </div>
        <div class="description">
            <p>Эмпирическое правило для setter injection: используйте dependency injection setter,
                которые не требуются для объекта. Эти зависимости не должны заменять
                функциональность внутреннего объекта, а должны расширять его.</p>
        </div>
    </div>
</div>
<div class="dependencyInjectionContainer">
    <h2>Dependency Injection Container</h2>
    <h4>Где нам создавать все эти зависимости?</h4>
    <div class="parent">
        <div class="Class">
            <p>final class Container</p>
            <p>{</p>
            <p class="p-l">public function makeDelivery(): Delivery</p>
            <p class="p-l">{</p>
            <p class="p-l-1">$httpClient = new HttpClient(
                'http://some-api.com'
                );</p>
            <p class="p-l-1">return new Delivery(</p>
            <p class="p-l-1">$httpClient, $logger</p>
            <p class="p-l-1">);</p>
            <p class="p-l">}</p>
            <p>}</p>
        </div>
        <div class="description">
            <p><a href="http://symfony.com/doc/current/components/dependency_injection.html">Symfony Component Dependency Injection</a></p>
        </div>
    </div>
</div>
<div class="dependencyInjectionSmells">
    <h2>Как не использовать!</h2>
    <h4></h4>
    <div class="parent">
        <div class="Class">
           <div class="error">
               <p>public function __construct(</p>
               <p class="p-l">OrdersRepository $ordersRepo,</p>
               <p class="p-l">PaymentGateway $payments,</p>
               <p class="p-l">ShippingService $shipping,</p>
               <p class="p-l">Logger $logger,</p>
               <p class="p-l">Email $mailer</p>
           </div>
        </div>
        <div class="description">
            <p>Слишком много зависимостей
                Когда у класса много зависимостей в конструкторе это первый признак того, что
                этот класс имеет слишком много обязанностей (нарушает Single Responsibility Principle<sup><b>S</b>OLID</sup>)</p>
            <p>Другой вариант - передать конструктору только контейнер, а затем разрешить все эти
                зависимости - <b>anti-pattern Service Locator</b></p>
        </div>
    </div>
</div>
<div class="closure">
    <h2>Замыкание</h2>
    <h5>
        Замыкание - это анонимная функция, которую можно сохранить в переменной
        и передать в качестве аргумента в другие функции или методы.
        Замыкания дают нам новую функциональность и возможность рефакторинга старого кода.</h5>
    <div class="parent">
        <div class="Class">
            <p>$heyFunc = function($name){</p>
            <p class="p-l">return "Hey, {$name}";</p>
            <p>}</p>
            <div class="error pb-1">
                <p>$var = 'hello';</p>
                <p>$func = function () {</p>
                <p class="p-l">echo $var;</p>
                <p>};</p>
            </div>
            <p>$var = 'hello';</p>
            <p>$func = function () use ($var) {</p>
            <p>echo $var;</p>
            <p>};</p>
            <p class="pb-1">$func(); // hello</p>

        </div>
        <div class="description">
            <p>Замыкание имеет отдельное пространство имен</p>
            <p>Изменение этих переменных
                внутри замыкания не имеет внешнего эффекта,
                если эти переменные не являются объектами (объекты всегда передаются по ссылке)</p>
            <div class="Class">
                <p>$var = 'hello';</p>
                <p>$func = function () use ($var) {</p>
                <p>echo $var = 'hi';</p>
                <p>};</p>
                <p class="pb-1">$func(); // hello</p>
            </div>
            <p>
                Если мы хотим изменить переменную $var, мы должны добавить амперсанд для передачи этой переменной по ссылке,
                как это:</p>
            <div class="Class">
                <p>$var = 'hello';</p>
                <p>$func = function () use (<b>&</b>$var) {</p>
                <p>echo $var = 'hi';</p>
                <p>};</p>
                <p class="pb-1">$func(); // hello</p>
            </div>
            <p>Когда мы создаем анонимную функцию и назначаем ее переменной, PHP превращает ее в объект
                класс Closure. Класс Closure - это особый класс. Мы не можем создать его экземпляры</p>
        </div>
    </div>

</div>
<hr>
<h1 class="centered">object-oriented design</h1>
<h1>SOLID Principles</h1>
<div class="solid">
    <div class="s solid__item">
        <h1>S</h1>
        <p>single responsibility</p>
        <p>принцип единичной ответственности</p>
        <p>цель - создать небольшие полезные классы, которые должны нести единственную ответственность</p>
        <div class="Class t-a-l">
            <div class="error">
                <p>class Category</p>
                <p>{</p>
                <p class="p-l">public function addProduct(Product $product): self</p>
                <p class="p-l">{</p>
                <p class="p-l-1">if (auth()->user() instanceof Admin) {</p>
                <p class="p-l-1">throw new UnAuthorizedException;</p>
                <p class="p-l-1">return $this;</p>
                <p class="p-l">}</p>
                <p>}</p>
                <p class="pb-1">Сколько обязанностей имеет class Category даже с этим маленьким образцом кода? Как минимум два:
                    addProduct и
                    проверка подлинности user.</p>
            </div>
            <p>class Category</p>
            <p>{</p>
            <p class="p-l">public function addProduct(Product $product): self</p>
            <p class="p-l">{</p>
            <p class="p-l-1">return $this;</p>
            <p class="p-l">}</p>
            <p>}</p>

    </div>
    </div>
    <div class="o solid__item">
        <h1>O</h1>
        <p>open-close</p>
        <p>принцип открытости закрытости</p>
    </div>
    <div class="l solid__item">
        <h1>L</h1>
        <p>Liskov Substitution</p>
        <p>Дочерние классы должны быть заменены на их родительские классы</p>
    </div>
    <div class="i solid__item">
        <h1>I</h1>
        <p>Interface Segregation</p>
        <p>принцип разделение интерфейса</p>
    </div>
    <div class="d solid__item">
        <h1>D</h1>
        <p>Dependency Inversion</p>
        <p>полагаться на абстракции</p>

    </div>
</div>

<h1>84</h1>

<!--

<h3>O -open-close</h3>
<h4>Принцип открытости закрытости </h4>
<h5>Классы должны быть открыты для расширения, но закрыты для модификации.</h5>
<h4>Смысл принципа - Конструкция системы должна быть проста и устойчива к изменениям</h4>
<h2>1</h2>
<p>interface Workable</p>
<p>{</p>
<p>public function work():void</p>
<p>}</p>
<hr>
<p>final class Programmer implements Workable</p>
<p>{</p>
<p>public function work(): void</p>
<p>{</p>
<p>echo 'coding an app';</p>
<p>}</p>
<hr>
<h2>2</h2>
<p>final class ProjectManager</p>
<p>{</p>
<p>public function manage(Workable $worker): void</p>
<p>{</p>
<p>$worker->work()</p>
<p>}</p>
<hr>
<h2>3</h2>
<p>final class Tester implements Workable</p>
<p>{</p>
<p>public function work(): void</p>
<p>{</p>
<p>echo 'testing an app';</p>
<p>}</p>
<p>}</p>
<hr>
<h3>Liskov Substitution</h3>
<h5>Дочерние классы должны быть заменяемыми на свои родительские классы</h5>
<h3>Принцип разделения интерфейса</h3>
<p>Когда вы обнаруживаете, что создаете интерфейсы, которые не полностью реализованы в их клиентах, вы
    нарушаете принцип разделения интерфейсов. Основная цель этого принципа - сделать интерфейсы. Разделение интерфейсов
    и принцип единой ответственности дополняют друг друга. Они служат той же цели: обеспечивают небольшие,
    очень сплоченные блоки. Принцип разделения интерфейса обеспечивает что интерфейсы небольшие,
    а принцип единой ответственности гарантирует, что классы будут небольшими.</p>
<hr>
<h3>Dependency Inversion Principle</h3>
<h5>Модули высокого уровня не должны зависеть от модулей низкого уровня</h5>
<p>100</p>-->

</body>
</html>